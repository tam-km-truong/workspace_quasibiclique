    
    sys.exit("Terminating program  before calling KP_QBc.")
    model = KP_QBc(cols_rem, nb_rows_rem, nb_edges_0_rem, rate)
    model.solve(GUROBI_CMD(msg=False, timeLimit= 300))
    # Check status
    if model.status == 9 : #GRB.TIME_LIMIT:
        print("Gurobi stopped due to time limit!")
    print("Gurobi Model Status:", model.status, "-", gp.GRB.Status.__dict__.get(model.status, "Unknown"))
    print("Model.status is ", model.status, "Exporting LP file for debugging...")
    model.writeLP("debug_model_col.lp")
    print(f"Model status: {LpStatus[model.status]}")
    if model.status == -1:
         print("Model is infeasible. Exporting LP file for debugging...")
         model.writeLP("debug_model.lp")
         sys.exit("Terminating program due to infeasibility. EXIT 7")
    #read the result from the solver
    cols_res=[]
    cols_del=[]
    if model.name == "column_knapsack_problem":
            for var in model.variables():
                if var.varValue == 0:
                    #print('column_knapsack var name =', var.name,'var value =', var.varValue)
                    if var.name[:3] == "col":
                        cols_res = cols_res + [var.name[4:]]
                    elif var.name[:3] == "row":
                #    cols_res = cols_res + [var.name[4:]]
                        print('Something wrong. var name =', var.name,'var value =', var.varValue)
                        return model 
                else: # i.e. var.varValue == 1:
                    if var.name[:3] == "col":
                        cols_del = cols_del + [var.name[4:]]
                    elif var.name[:3] == "row":
                        #cols_del = cols_del + [var.name[4:]]
                        print('Something wrong. var name =', var.name,'var value =', var.varValue)
                        return model 
                    
    print_log_output(model) 
    print()
    print('-' * 40)           
    print('after col kp solution !!!!!!!!!!!! ')
    print(' number of cols_res =', len(cols_res))
    print(' number of  cols_del =', len(cols_del)) 
    print(' number of  rows_rem =', len(rows_rem))
    print(' number of rows_del =', len(rows_del))
    #sys.exit("Terminating program due to inexpected end. EXIT after col KP ")

    rows_rem, cols_rem, edges_1_rem, nb_edges_0_rem, density = update_data(rows, cols, edges_1, rows_res, cols_res, debug) 

    print()
    print(f"model = {model.name}", "rate =  ", rate)
    print('after update_data !!!!!!!!!!!! ')
    print(' number of cols_rem =', len(cols_rem))
    print('number of cols_res =', len(cols_res))
    print('number of rows_rem =', len(rows_rem))
    print('number of rows_res =', len(rows_res)) 
    print('number of nb_edges_0_rem =', nb_edges_0_rem)
    print('number of edges_1_rem =', len(edges_1_rem))
    print('density =', density) 


    #df.iloc[list(map(int, rows_res)) list(map(int, cols_res))]
    # nb_0 = len(rows_res)*len(cols_res)-df.iloc[list(map(int, rows_res)), list(map(int, cols_res))].sum().sum()
    # nb_1 =  df.iloc[list(map(int, rows_res)), list(map(int, cols_res))].sum().sum()
    

    nb_0 = 0
    nb_1 = 0
    for _, degree in rows_rem: #number of ones counting 
        nb_1 = nb_1 + degree
    surface = len(rows_rem)*len(cols_rem)
    nb_0 = surface - nb_1 #number of zeros counting 
    print('-' * 40)
    print("nb_remaining_row:", len(rows_rem) )
    print("number current zeros  = ", nb_0,"number current ones = ",nb_1, "current surface  = ", surface, "rate = ", rate)
    print("current sparsity = ", nb_0/surface, "current density = ", nb_1/surface )
    print('End current Stats (I will call max_e_r with rows_rem, cols_rem and edges_1_rem ')
    print('-' * 40)
    print()
           
    model = max_e_r(rows_rem, cols_rem, edges_1_rem, rate=0.1)
    #model = max_v(rows_rem, cols_rem, edges_1_rem, rate=0.1)

    model.solve(GUROBI_CMD(msg=False, timeLimit= 300))
    # Check status
    # if model.status == GRB.Status.TIME_LIMIT:
    #     print("Gurobi stopped due to time limit!")
    
    print(f" Check status  model =", model.name, "Model status:", model.status)
    print_log_output(model)
    model.writeLP("debug_model_AB_E.lp")
    print(f"Model status: {LpStatus[model.status]}")
    if model.status == -1:
         print("Model is infeasible. Exporting LP file for debugging...")
         model.writeLP("debug_model.lp")
         sys.exit("Terminating program due to infeasibility. EXIT 8")
    print_log_output(model)

    if debug >=1:
        print(f"Extracting of the computed results")
    #read the results from the solver
    rows_res = []
    cols_res = []
    rows_res_name = []
    cols_res_name = []
  #  rows_del = []
    rows_del_name = []
    cols_del = []
    cols_del_name = []
    obj_total =  0.0

    if  model.name == 'max_e' or model.name == 'max_e_r'  or model.name == 'max_e_h' or model.name == 'max_v': 
        print('I solved model name =', model.name)
        for var in model.variables():
            if var.name[:3] == "row" or var.name[:3] == "col":
                #print('max_e model var name =', var.name,'var value =', var.varValue)
            #if var.varValue == 1:
                if var.varValue !=  0: # i.e. var.varValue == 0:
                    if var.name[:3] == "row":
                         rows_res = rows_res + [var.name[4:]]
                    elif var.name[:3] == "col":
                        cols_res = cols_res + [var.name[4:]]
                else: # i.e. var.varValue == 0:
                    if var.name[:3] == "row":
                        rows_del = rows_del + [var.name[4:]]
                    elif var.name[:3] == "col":
                        cols_del = cols_del + [var.name[4:]]
    else:
        sys.exit("Terminating program due to inexpected end. EXIT 2 ")
    if  model.name == 'max_e' or  model.name == 'max_e_r' or model.name == 'max_v'  or model.name == 'max_e_h': 
        rows_next, cols_next, edges_1_next, nb_edges_0_next, density = update_data(rows_rem, cols_rem, edges_1_rem, rows_res, cols_res, debug)
        size = len(rows_next) * len(cols_next)
        print('-' * 40)
        print()
        print(f"model = {model.name}", "given rate = ", rate)
        print("Found matrix : ", len(rows_next), "*", len(cols_next), "=", size, "density = ", density,  "nb_edges_1_next  = ", len(edges_1_next), "nb_edges_0_next  = ", nb_edges_0_next)
       # print("rows_rem  =  we need to modify this ",rows_rem) 
        #print("cols_rem  =  we need to modify this ",cols_rem) 
        print("rows_next  =  we need to modify this ",len(rows_next))
        print("cols_next  =  we need to modify this ",len(cols_next))  
        # print("rows_res  = ",rows_res) 
        # print("cols_res  = ",cols_res)
        # print("rows_del  = ",rows_del) 
        # print("cols_del  = ",cols_del)
        # print("edges_1_rem  = ", edges_1_rem)
        # print("edges_1_next  = ", edges_1_next)
        print("nb_edges_0_next  = ", nb_edges_0_next)
        # rows_res_int = set(map(int, rows_res))
        # # Filter tuples where the first element is in cols_res_int
        # rows_last = [tup for tup in rows_rem if tup[0] in rows_res_int]
        # for _, degree in rows_last: #number of ones counting 
        #      nb_1 = nb_1 + degree
        # nb_0 = surface - nb_1 #number of zeros counting 
        # print("number Final zeros  = ",nb_0)     
        # print("number Final ones = ",nb_1)            
        # print("Final sparsity = ", nb_0/surface)
        # print("Final density = ", nb_1/surface)
        print('End Final Stats')
        print('-' * 40)
        print()
        if len(rows_next)== 0 or len(cols_next)==0 : 
            print("final matrix degenerated (all rows or all columns have been deleted)")
            sys.exit("Terminating program due to matrix degenerattion. EXIT 5")
        else : 
                print(f"model = {model.name}", "required rate =   ", rate)
                print("Found matrix : ", len(rows_next), "*", len(cols_next), "=", size, "density = ", density, "nb_edges_0_next  = ", nb_edges_0_next, "nb_edges_1_next  = ", len(edges_1_next))
                print(" number rows_next", len(rows_next))
                print(" number cols_next", len(cols_next))
                rows_sol = [str(c) for c, _ in rows_next]
                rows_sol = [int(r) for r in rows_sol]
                cols_sol = [str(c) for c, _ in cols_next]
                cols_sol = [int(c) for c in cols_sol]
                print(" solution rows ", rows_sol)
                print(" columns rows ", cols_sol)

    else: 
        sys.exit("Terminating program due to inexpected end. EXIT 3 (before return  model)")
  
    return rows_res, cols_res # should be    rows_next, cols_next, edges_1_next, nb_edges_0_next, density !!! if max_e after KPc and KPr
#########################################################################
#  What is the code above 